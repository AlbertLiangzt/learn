			混淆表			|  分类器预测类别 	|		|		混淆表	   |		分类器预测类别		|
							|	类别A   | 类别B	|		|				   |       +1     |    -1       |
----------------------------|-------------------|		|------------------|----------------------------|
				| 类别A(60) |	50		|	10	|		|			| +1   |  真正例(TP)  |  伪反例(FN) |
	实际类别	|-----------|-------------------|		|实际类别	|------|----------------------------|
				| 类别B(40) |   5		|   35	|		|			| -1   |  伪正例(FP)  |  真反例(TN) |
------------------------------------------------|		|-------------------------------------------------

准确度Accuracy: (50+35)/(35+5+10+50)=85%
正确率Precision-A: 50/(50+5)=90.9%		正确率Precision：TP/(TP+FP)	-正例的样本中的真正正例的比例
召回率Recall-A: 50/(50+10)=83.3%		召回率Recall：TP/(TP+FN)	-预测正例的真正正例的比例


评估方法：
	混淆矩阵——PR，ROC(Receiver Operating Characteristic curve接收者操作特征曲线)，AUC(Area Under Curve ROC曲线下的面积)

ROC曲线：
纵轴-真阳率：TP/(TP+FN)
横轴-假阳率：FP/(FP+TN)

AUC求值两种方法：
1.求ROC曲线下面积
2.负样本排在正样本前面的概率


ROC结果
无图形	cat auc.raw | sort -t$'\t' -k2g  | awk -F'\t' '($1==-1){++x;a+=y}($1==1){++y}END{print 1.0 - a/(x*y)}'

	x：表示负样本的个数M=50
	y：表示正样本的个数N=20
	a：错误的累加

	x*y = M*N = 1000  <xi, yj>
	如果xi在yj前面，a不累计
	如果xi在yj后面，a累计
	a/(x*y) : 错误率
	1-a/(x*y)：正确率
	
有图形	python plot_roc.py auc.raw
